<!DOCTYPE html>
<html>
<head>
  <title>Roblox at Home</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    html, body { margin: 0; overflow: hidden; height: 100%; }
    canvas { width: 100%; height: 100%; display: block; }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <script>
    // ðŸ”® Babylon setup
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.ArcRotateCamera("camera", Math.PI/2, Math.PI/4, 10, BABYLON.Vector3.Zero(), scene);
    camera.attachControl(canvas, true);
    new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // ðŸ§© Graphics.new() with duplicate removal + collision + size
    const graphics = {
      new: function(type, props = {}) {
        const name = type;
        const existing = scene.getMeshByName(name);
        if (existing) existing.dispose();

        let mesh;
        switch(type) {
          case "cube":
            mesh = BABYLON.MeshBuilder.CreateBox(name, {
              width: props.size?.x || 1,
              height: props.size?.y || 1,
              depth: props.size?.z || 1
            }, scene);
            break;
          case "sphere":
            mesh = BABYLON.MeshBuilder.CreateSphere(name, {
              diameterX: props.size?.x || 1,
              diameterY: props.size?.y || 1,
              diameterZ: props.size?.z || 1
            }, scene);
            break;
        }

        if (!mesh) return null;

        // Position ritual
        if (props.x !== undefined) mesh.position.x = props.x;
        if (props.y !== undefined) mesh.position.y = props.y;
        if (props.z !== undefined) mesh.position.z = props.z;

        // Collision ritual
        if (props.collision === true) mesh.checkCollisions = true;

        return mesh;
      }
          // â±ï¸ wait(t)
    function wait(seconds) {
      return new Promise(resolve => setTimeout(resolve, seconds * 1000));
    }

    // ðŸ”§ Convert Lua-style {x=0, y=1} to JS-style {"x":0, "y":1}
    function luaToJSObject(luaStr) {
      return luaStr.replace(/(\w+)\s*=/g, '"$1":');
    }

    // ðŸ§  Interpreter
    async function runScript(code) {
      const lines = code.split("\n");
      for (let line of lines) {
        line = line.trim();
        if (line.startsWith("wait(")) {
          const t = parseFloat(line.match(/wait\(([^)]+)\)/)[1]);
          await wait(t);
        } else if (line.startsWith("local ")) {
          // handle local cube = graphics.new(...)
          const match = line.match(/local (\w+)\s*=\s*graphics\.new\("([^"]+)",\s*(\{.*\})\)/);
          if (match) {
            const varName = match[1];
            const type = match[2];
            const rawProps = match[3];
            const jsProps = luaToJSObject(rawProps);
            const props = eval("(" + jsProps + ")");
            window[varName] = graphics.new(type, props);
          }
        } else if (line.includes(".size = Vector3.new")) {
          const match = line.match(/(\w+)\.size\s*=\s*Vector3\.new\(([^)]+)\)/);
          if (match) {
            const varName = match[1];
            const values = match[2].split(",").map(v => parseFloat(v.trim()));
            const mesh = window[varName];
            if (mesh) {
              mesh.scaling = new BABYLON.Vector3(values[0], values[1], values[2]);
            }
          }
        } else if (line.startsWith("graphics.new")) {
          const match = line.match(/graphics\.new\("([^"]+)",\s*(\{.*\})\)/);
          if (match) {
            const type = match[1];
            const rawProps = match[2];
            const jsProps = luaToJSObject(rawProps);
            const props = eval("(" + jsProps + ")");
            graphics.new(type, props);
          }
        } else if (line.startsWith("print(")) {
          const msg = line.match(/print\(([^)]+)\)/)[1];
          console.log(eval(msg));
        }
      }
    }

    // ðŸ“œ Load cube.lua and run it
    fetch("cube.lua")
      .then(res => res.text())
      .then(code => runScript(code));

    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>

    };
